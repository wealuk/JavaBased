package com.atguigu.java;
/*
 * 子类对象实例化的全过程
 * 
 * 1.从结果上来看：（继承性）
 * 			子类继承父类以后，就获得了父类中声明的属性和方法
 * 			创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
 * 
 * 2.从过程来看：
 * 			当我们通过子类的构造器创建子类的对象时，我们一定会直接或间接的调用其父类的构造器，进而
 * 			调用其父类的父类的构造器，直到调用了java.lang.Object类中的空参构造器为止。正因为
 * 			加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑调用
 * notes:构造器中因为super放在第一行，就会一直调到Object的构造器。所以子类继承父类的内容是
 * 先继承最高父类(object)的再继承其子类的内容。(虽然子类构造器先加载，但是先
 * 加载完内容的是父类，然后是其子类)--->这里在OOP3中的代码块中有个细节要区分明白
 * 
 * 明确：虽然创建子类对象时，调用了父类的构造器。但是至始至终就创建过一个对象，即为new的子类对象
 * 
 * 
 * 
 */
public class OOPTest07 {

	//继承和super课后练习见com.atguigu.exer1
}
