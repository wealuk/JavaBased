package com.atguigu.java;
/*
 * 面向对象特征之三：多态性
 * 
 * 1.理解多态性，可以理解为一个事物的多种形态
 * 2.何为多态性：
 * 		对象的多态性：父类的引用指向子类的对象(或子类的对象赋给父类的引用)
 * 
 * 3.多态的使用：虚拟方法的调用
 * 		有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法；但在运行期，我们实际执行的
 * 		是子类重写父类的方法。
 * 	总结：编译，看左边；运行，看右边
 * 
 * 4.多态性的使用前提：①要有类的继承关系(父类的引用指向子类的对象)	
 * 					②方法的重写(编译只能通过父类的方法，所以只有重写的方法才能调用)
 * 使用示例1见Animal
 * 
 * 5.对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边)。（属性不能被覆盖）
 * 
 * notes：方法中，实参对象是形参的子类时，此时就体现了多态性
 * 
 * 抽象类、接口的使用肯定体现了多态性（抽象类、接口不能实例化）
 * 
 */
public class OOPTest08 {

	public static void main(String[] args) {
		Person p1 = new Person();
		p1.eat();
		
		Man man = new Man();
		man.eat();
		man.age = 25;
		man.eartnMoney();
		
		
		System.out.println("***********");
		//对象的多态性，父类的引用指向子类的对象
		Person p2 = new Man();
		//Person p3 = new Woman();
		//多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法--虚拟方法的调用
		p2.eat();    //执行时运行的是子类的重写方法
		p2.walk();
		
		//不能调用子类所特有的属性、方法。但这些属性和方法在p2所对应的内存中是存在的
		//只是不属于Person类所以无法调用
//		p2.earnMoney报错，	编译时只能调用父类的属性和方法，p2是Person类
		System.out.println(p2.id);//1001，属性不能被覆盖，所以是谁的编译就运行谁。编译运行都看左边
	}
}
